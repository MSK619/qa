export const sc = [
  {
    question: "How to handle automatic logout after system inactivity?",
    answer: [
      "Idle time tracking.",
      "User activity listeners.",
      "Session timeout policy.",
      "Auto logout mechanism.",
      "Pre-logout warning."
    ],
    open: false
  },
  {
    question: "How to handle 100 API calls in parallel?",
    answer: [
      "Parallel execution strategy.",
      "Concurrency limiting.",
      "Request batching.",
      "Graceful error handling.",
      "Performance monitoring."
    ],
    open: false
  },
  {
    question: "How would you design a scalable frontend architecture?",
    answer: [
      "Modular architecture.",
      "Lazy-loaded feature modules.",
      "State management strategy.",
      "Reusable shared components.",
      "Clear separation of concerns."
    ],
    open: false
  },
  {
    question: "How do you handle memory leaks in frontend applications?",
    answer: [
      "Unsubscribe from observables.",
      "Clean up event listeners.",
      "Avoid global references.",
      "Use async pipes.",
      "Monitor performance tools."
    ],
    open: false
  },
  {
    question: "How would you implement role-based access control (RBAC)?",
    answer: [
      "Role-based permissions.",
      "Route guards.",
      "UI-level access checks.",
      "Backend authorization sync.",
      "Centralized auth service."
    ],
    open: false
  },
  {
    question: "How do you optimize frontend application performance?",
    answer: [
      "Lazy loading.",
      "Code splitting.",
      "Change detection optimization.",
      "Asset optimization.",
      "Caching strategies."
    ],
    open: false
  },
  {
    question: "How would you handle large-scale state management?",
    answer: [
      "Centralized state store.",
      "Immutable state updates.",
      "Selective state subscriptions.",
      "State normalization.",
      "Side-effect isolation."
    ],
    open: false
  },
  {
    question: "How do you design a fault-tolerant frontend system?",
    answer: [
      "Graceful error handling.",
      "Retry mechanisms.",
      "Fallback UI states.",
      "Offline support.",
      "Monitoring and logging."
    ],
    open: false
  },
  {
    question: "How would you handle authentication token expiration?",
    answer: [
      "Token expiry detection.",
      "Refresh token strategy.",
      "Request retry handling.",
      "Silent re-authentication.",
      "Forced logout fallback."
    ],
    open: false
  },
  {
    question: "How do you manage environment-specific configurations?",
    answer: [
      "Environment-based config files.",
      "Build-time configuration.",
      "Runtime configuration loading.",
      "Secure secret handling.",
      "CI/CD integration."
    ],
    open: false
  }
];
